/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getStructEncoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from "@solana/kit";
import { OPTION_PROGRAM_PROGRAM_ADDRESS } from "../programs";
import {
  expectAddress,
  getAccountMetaFactory,
  type ResolvedAccount,
} from "../shared";

export const OPTION_EXERCISE_DISCRIMINATOR = new Uint8Array([
  43, 86, 237, 78, 235, 74, 131, 206,
]);

export function getOptionExerciseDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    OPTION_EXERCISE_DISCRIMINATOR,
  );
}

export type OptionExerciseInstruction<
  TProgram extends string = typeof OPTION_PROGRAM_PROGRAM_ADDRESS,
  TAccountOptionAccount extends string | AccountMeta<string> = string,
  TAccountPositionAccount extends string | AccountMeta<string> = string,
  TAccountMarketData extends string | AccountMeta<string> = string,
  TAccountUnderlyingMint extends string | AccountMeta<string> = string,
  TAccountPriceUpdate extends string | AccountMeta<string> = string,
  TAccountBuyerPaymentAccount extends string | AccountMeta<string> = string,
  TAccountMakerCollateralAccount extends string | AccountMeta<string> = string,
  TAccountEscrowState extends string | AccountMeta<string> = string,
  TAccountEscrowTokenAccount extends string | AccountMeta<string> = string,
  TAccountEscrowAuthority extends string | AccountMeta<string> = string,
  TAccountBuyer extends string | AccountMeta<string> = string,
  TAccountTokenProgram extends string | AccountMeta<string> =
    "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountOptionAccount extends string
        ? WritableAccount<TAccountOptionAccount>
        : TAccountOptionAccount,
      TAccountPositionAccount extends string
        ? WritableAccount<TAccountPositionAccount>
        : TAccountPositionAccount,
      TAccountMarketData extends string
        ? ReadonlyAccount<TAccountMarketData>
        : TAccountMarketData,
      TAccountUnderlyingMint extends string
        ? ReadonlyAccount<TAccountUnderlyingMint>
        : TAccountUnderlyingMint,
      TAccountPriceUpdate extends string
        ? ReadonlyAccount<TAccountPriceUpdate>
        : TAccountPriceUpdate,
      TAccountBuyerPaymentAccount extends string
        ? WritableAccount<TAccountBuyerPaymentAccount>
        : TAccountBuyerPaymentAccount,
      TAccountMakerCollateralAccount extends string
        ? WritableAccount<TAccountMakerCollateralAccount>
        : TAccountMakerCollateralAccount,
      TAccountEscrowState extends string
        ? ReadonlyAccount<TAccountEscrowState>
        : TAccountEscrowState,
      TAccountEscrowTokenAccount extends string
        ? WritableAccount<TAccountEscrowTokenAccount>
        : TAccountEscrowTokenAccount,
      TAccountEscrowAuthority extends string
        ? ReadonlyAccount<TAccountEscrowAuthority>
        : TAccountEscrowAuthority,
      TAccountBuyer extends string
        ? WritableSignerAccount<TAccountBuyer> &
            AccountSignerMeta<TAccountBuyer>
        : TAccountBuyer,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      ...TRemainingAccounts,
    ]
  >;

export type OptionExerciseInstructionData = {
  discriminator: ReadonlyUint8Array;
};

export type OptionExerciseInstructionDataArgs = {};

export function getOptionExerciseInstructionDataEncoder(): FixedSizeEncoder<OptionExerciseInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([["discriminator", fixEncoderSize(getBytesEncoder(), 8)]]),
    (value) => ({ ...value, discriminator: OPTION_EXERCISE_DISCRIMINATOR }),
  );
}

export function getOptionExerciseInstructionDataDecoder(): FixedSizeDecoder<OptionExerciseInstructionData> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
  ]);
}

export function getOptionExerciseInstructionDataCodec(): FixedSizeCodec<
  OptionExerciseInstructionDataArgs,
  OptionExerciseInstructionData
> {
  return combineCodec(
    getOptionExerciseInstructionDataEncoder(),
    getOptionExerciseInstructionDataDecoder(),
  );
}

export type OptionExerciseAsyncInput<
  TAccountOptionAccount extends string = string,
  TAccountPositionAccount extends string = string,
  TAccountMarketData extends string = string,
  TAccountUnderlyingMint extends string = string,
  TAccountPriceUpdate extends string = string,
  TAccountBuyerPaymentAccount extends string = string,
  TAccountMakerCollateralAccount extends string = string,
  TAccountEscrowState extends string = string,
  TAccountEscrowTokenAccount extends string = string,
  TAccountEscrowAuthority extends string = string,
  TAccountBuyer extends string = string,
  TAccountTokenProgram extends string = string,
> = {
  optionAccount: Address<TAccountOptionAccount>;
  positionAccount: Address<TAccountPositionAccount>;
  /** Market data for risk-free rate (used in Black-Scholes premium calculation) */
  marketData: Address<TAccountMarketData>;
  /** Underlying token mint (for dynamic decimal handling - supports any SPL token) */
  underlyingMint: Address<TAccountUnderlyingMint>;
  /** Pyth price update account (ownership validated by Anchor) */
  priceUpdate: Address<TAccountPriceUpdate>;
  buyerPaymentAccount: Address<TAccountBuyerPaymentAccount>;
  makerCollateralAccount: Address<TAccountMakerCollateralAccount>;
  /**
   * Escrow state PDA - validates maker/mint binding
   * Validates escrow_state.maker matches option_account.authority (the option's maker)
   */
  escrowState: Address<TAccountEscrowState>;
  /** Escrow token account holding collateral */
  escrowTokenAccount: Address<TAccountEscrowTokenAccount>;
  escrowAuthority?: Address<TAccountEscrowAuthority>;
  buyer: TransactionSigner<TAccountBuyer>;
  tokenProgram?: Address<TAccountTokenProgram>;
};

export async function getOptionExerciseInstructionAsync<
  TAccountOptionAccount extends string,
  TAccountPositionAccount extends string,
  TAccountMarketData extends string,
  TAccountUnderlyingMint extends string,
  TAccountPriceUpdate extends string,
  TAccountBuyerPaymentAccount extends string,
  TAccountMakerCollateralAccount extends string,
  TAccountEscrowState extends string,
  TAccountEscrowTokenAccount extends string,
  TAccountEscrowAuthority extends string,
  TAccountBuyer extends string,
  TAccountTokenProgram extends string,
  TProgramAddress extends Address = typeof OPTION_PROGRAM_PROGRAM_ADDRESS,
>(
  input: OptionExerciseAsyncInput<
    TAccountOptionAccount,
    TAccountPositionAccount,
    TAccountMarketData,
    TAccountUnderlyingMint,
    TAccountPriceUpdate,
    TAccountBuyerPaymentAccount,
    TAccountMakerCollateralAccount,
    TAccountEscrowState,
    TAccountEscrowTokenAccount,
    TAccountEscrowAuthority,
    TAccountBuyer,
    TAccountTokenProgram
  >,
  config?: { programAddress?: TProgramAddress },
): Promise<
  OptionExerciseInstruction<
    TProgramAddress,
    TAccountOptionAccount,
    TAccountPositionAccount,
    TAccountMarketData,
    TAccountUnderlyingMint,
    TAccountPriceUpdate,
    TAccountBuyerPaymentAccount,
    TAccountMakerCollateralAccount,
    TAccountEscrowState,
    TAccountEscrowTokenAccount,
    TAccountEscrowAuthority,
    TAccountBuyer,
    TAccountTokenProgram
  >
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? OPTION_PROGRAM_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    optionAccount: { value: input.optionAccount ?? null, isWritable: true },
    positionAccount: { value: input.positionAccount ?? null, isWritable: true },
    marketData: { value: input.marketData ?? null, isWritable: false },
    underlyingMint: { value: input.underlyingMint ?? null, isWritable: false },
    priceUpdate: { value: input.priceUpdate ?? null, isWritable: false },
    buyerPaymentAccount: {
      value: input.buyerPaymentAccount ?? null,
      isWritable: true,
    },
    makerCollateralAccount: {
      value: input.makerCollateralAccount ?? null,
      isWritable: true,
    },
    escrowState: { value: input.escrowState ?? null, isWritable: false },
    escrowTokenAccount: {
      value: input.escrowTokenAccount ?? null,
      isWritable: true,
    },
    escrowAuthority: {
      value: input.escrowAuthority ?? null,
      isWritable: false,
    },
    buyer: { value: input.buyer ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Resolve default values.
  if (!accounts.escrowAuthority.value) {
    accounts.escrowAuthority.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            101, 115, 99, 114, 111, 119, 95, 97, 117, 116, 104, 111, 114, 105,
            116, 121, 95, 118, 50,
          ]),
        ),
        getAddressEncoder().encode(expectAddress(accounts.escrowState.value)),
      ],
    });
  }
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address<"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA">;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.optionAccount),
      getAccountMeta(accounts.positionAccount),
      getAccountMeta(accounts.marketData),
      getAccountMeta(accounts.underlyingMint),
      getAccountMeta(accounts.priceUpdate),
      getAccountMeta(accounts.buyerPaymentAccount),
      getAccountMeta(accounts.makerCollateralAccount),
      getAccountMeta(accounts.escrowState),
      getAccountMeta(accounts.escrowTokenAccount),
      getAccountMeta(accounts.escrowAuthority),
      getAccountMeta(accounts.buyer),
      getAccountMeta(accounts.tokenProgram),
    ],
    data: getOptionExerciseInstructionDataEncoder().encode({}),
    programAddress,
  } as OptionExerciseInstruction<
    TProgramAddress,
    TAccountOptionAccount,
    TAccountPositionAccount,
    TAccountMarketData,
    TAccountUnderlyingMint,
    TAccountPriceUpdate,
    TAccountBuyerPaymentAccount,
    TAccountMakerCollateralAccount,
    TAccountEscrowState,
    TAccountEscrowTokenAccount,
    TAccountEscrowAuthority,
    TAccountBuyer,
    TAccountTokenProgram
  >);
}

export type OptionExerciseInput<
  TAccountOptionAccount extends string = string,
  TAccountPositionAccount extends string = string,
  TAccountMarketData extends string = string,
  TAccountUnderlyingMint extends string = string,
  TAccountPriceUpdate extends string = string,
  TAccountBuyerPaymentAccount extends string = string,
  TAccountMakerCollateralAccount extends string = string,
  TAccountEscrowState extends string = string,
  TAccountEscrowTokenAccount extends string = string,
  TAccountEscrowAuthority extends string = string,
  TAccountBuyer extends string = string,
  TAccountTokenProgram extends string = string,
> = {
  optionAccount: Address<TAccountOptionAccount>;
  positionAccount: Address<TAccountPositionAccount>;
  /** Market data for risk-free rate (used in Black-Scholes premium calculation) */
  marketData: Address<TAccountMarketData>;
  /** Underlying token mint (for dynamic decimal handling - supports any SPL token) */
  underlyingMint: Address<TAccountUnderlyingMint>;
  /** Pyth price update account (ownership validated by Anchor) */
  priceUpdate: Address<TAccountPriceUpdate>;
  buyerPaymentAccount: Address<TAccountBuyerPaymentAccount>;
  makerCollateralAccount: Address<TAccountMakerCollateralAccount>;
  /**
   * Escrow state PDA - validates maker/mint binding
   * Validates escrow_state.maker matches option_account.authority (the option's maker)
   */
  escrowState: Address<TAccountEscrowState>;
  /** Escrow token account holding collateral */
  escrowTokenAccount: Address<TAccountEscrowTokenAccount>;
  escrowAuthority: Address<TAccountEscrowAuthority>;
  buyer: TransactionSigner<TAccountBuyer>;
  tokenProgram?: Address<TAccountTokenProgram>;
};

export function getOptionExerciseInstruction<
  TAccountOptionAccount extends string,
  TAccountPositionAccount extends string,
  TAccountMarketData extends string,
  TAccountUnderlyingMint extends string,
  TAccountPriceUpdate extends string,
  TAccountBuyerPaymentAccount extends string,
  TAccountMakerCollateralAccount extends string,
  TAccountEscrowState extends string,
  TAccountEscrowTokenAccount extends string,
  TAccountEscrowAuthority extends string,
  TAccountBuyer extends string,
  TAccountTokenProgram extends string,
  TProgramAddress extends Address = typeof OPTION_PROGRAM_PROGRAM_ADDRESS,
>(
  input: OptionExerciseInput<
    TAccountOptionAccount,
    TAccountPositionAccount,
    TAccountMarketData,
    TAccountUnderlyingMint,
    TAccountPriceUpdate,
    TAccountBuyerPaymentAccount,
    TAccountMakerCollateralAccount,
    TAccountEscrowState,
    TAccountEscrowTokenAccount,
    TAccountEscrowAuthority,
    TAccountBuyer,
    TAccountTokenProgram
  >,
  config?: { programAddress?: TProgramAddress },
): OptionExerciseInstruction<
  TProgramAddress,
  TAccountOptionAccount,
  TAccountPositionAccount,
  TAccountMarketData,
  TAccountUnderlyingMint,
  TAccountPriceUpdate,
  TAccountBuyerPaymentAccount,
  TAccountMakerCollateralAccount,
  TAccountEscrowState,
  TAccountEscrowTokenAccount,
  TAccountEscrowAuthority,
  TAccountBuyer,
  TAccountTokenProgram
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? OPTION_PROGRAM_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    optionAccount: { value: input.optionAccount ?? null, isWritable: true },
    positionAccount: { value: input.positionAccount ?? null, isWritable: true },
    marketData: { value: input.marketData ?? null, isWritable: false },
    underlyingMint: { value: input.underlyingMint ?? null, isWritable: false },
    priceUpdate: { value: input.priceUpdate ?? null, isWritable: false },
    buyerPaymentAccount: {
      value: input.buyerPaymentAccount ?? null,
      isWritable: true,
    },
    makerCollateralAccount: {
      value: input.makerCollateralAccount ?? null,
      isWritable: true,
    },
    escrowState: { value: input.escrowState ?? null, isWritable: false },
    escrowTokenAccount: {
      value: input.escrowTokenAccount ?? null,
      isWritable: true,
    },
    escrowAuthority: {
      value: input.escrowAuthority ?? null,
      isWritable: false,
    },
    buyer: { value: input.buyer ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Resolve default values.
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address<"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA">;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.optionAccount),
      getAccountMeta(accounts.positionAccount),
      getAccountMeta(accounts.marketData),
      getAccountMeta(accounts.underlyingMint),
      getAccountMeta(accounts.priceUpdate),
      getAccountMeta(accounts.buyerPaymentAccount),
      getAccountMeta(accounts.makerCollateralAccount),
      getAccountMeta(accounts.escrowState),
      getAccountMeta(accounts.escrowTokenAccount),
      getAccountMeta(accounts.escrowAuthority),
      getAccountMeta(accounts.buyer),
      getAccountMeta(accounts.tokenProgram),
    ],
    data: getOptionExerciseInstructionDataEncoder().encode({}),
    programAddress,
  } as OptionExerciseInstruction<
    TProgramAddress,
    TAccountOptionAccount,
    TAccountPositionAccount,
    TAccountMarketData,
    TAccountUnderlyingMint,
    TAccountPriceUpdate,
    TAccountBuyerPaymentAccount,
    TAccountMakerCollateralAccount,
    TAccountEscrowState,
    TAccountEscrowTokenAccount,
    TAccountEscrowAuthority,
    TAccountBuyer,
    TAccountTokenProgram
  >);
}

export type ParsedOptionExerciseInstruction<
  TProgram extends string = typeof OPTION_PROGRAM_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    optionAccount: TAccountMetas[0];
    positionAccount: TAccountMetas[1];
    /** Market data for risk-free rate (used in Black-Scholes premium calculation) */
    marketData: TAccountMetas[2];
    /** Underlying token mint (for dynamic decimal handling - supports any SPL token) */
    underlyingMint: TAccountMetas[3];
    /** Pyth price update account (ownership validated by Anchor) */
    priceUpdate: TAccountMetas[4];
    buyerPaymentAccount: TAccountMetas[5];
    makerCollateralAccount: TAccountMetas[6];
    /**
     * Escrow state PDA - validates maker/mint binding
     * Validates escrow_state.maker matches option_account.authority (the option's maker)
     */
    escrowState: TAccountMetas[7];
    /** Escrow token account holding collateral */
    escrowTokenAccount: TAccountMetas[8];
    escrowAuthority: TAccountMetas[9];
    buyer: TAccountMetas[10];
    tokenProgram: TAccountMetas[11];
  };
  data: OptionExerciseInstructionData;
};

export function parseOptionExerciseInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>,
): ParsedOptionExerciseInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 12) {
    // TODO: Coded error.
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      optionAccount: getNextAccount(),
      positionAccount: getNextAccount(),
      marketData: getNextAccount(),
      underlyingMint: getNextAccount(),
      priceUpdate: getNextAccount(),
      buyerPaymentAccount: getNextAccount(),
      makerCollateralAccount: getNextAccount(),
      escrowState: getNextAccount(),
      escrowTokenAccount: getNextAccount(),
      escrowAuthority: getNextAccount(),
      buyer: getNextAccount(),
      tokenProgram: getNextAccount(),
    },
    data: getOptionExerciseInstructionDataDecoder().decode(instruction.data),
  };
}
