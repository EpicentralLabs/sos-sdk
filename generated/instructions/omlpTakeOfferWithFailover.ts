/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from "@solana/kit";
import { OPTION_PROGRAM_PROGRAM_ADDRESS } from "../programs";
import {
  expectAddress,
  expectSome,
  getAccountMetaFactory,
  type ResolvedAccount,
} from "../shared";

export const OMLP_TAKE_OFFER_WITH_FAILOVER_DISCRIMINATOR = new Uint8Array([
  39, 155, 118, 226, 84, 159, 5, 76,
]);

export function getOmlpTakeOfferWithFailoverDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    OMLP_TAKE_OFFER_WITH_FAILOVER_DISCRIMINATOR,
  );
}

export type OmlpTakeOfferWithFailoverInstruction<
  TProgram extends string = typeof OPTION_PROGRAM_PROGRAM_ADDRESS,
  TAccountDualContract extends string | AccountMeta<string> = string,
  TAccountRouter extends string | AccountMeta<string> = string,
  TAccountVault extends string | AccountMeta<string> = string,
  TAccountVaultTokenAccount extends string | AccountMeta<string> = string,
  TAccountEscrowAccount extends string | AccountMeta<string> = string,
  TAccountEscrowAuthority extends string | AccountMeta<string> = string,
  TAccountSap2Program extends string | AccountMeta<string> = string,
  TAccountSap2LoanAccount extends string | AccountMeta<string> = string,
  TAccountSap2OfferAccount extends string | AccountMeta<string> = string,
  TAccountMaker extends string | AccountMeta<string> = string,
  TAccountTokenProgram extends string | AccountMeta<string> =
    "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
  TAccountSystemProgram extends string | AccountMeta<string> =
    "11111111111111111111111111111111",
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountDualContract extends string
        ? WritableAccount<TAccountDualContract>
        : TAccountDualContract,
      TAccountRouter extends string
        ? WritableAccount<TAccountRouter>
        : TAccountRouter,
      TAccountVault extends string
        ? WritableAccount<TAccountVault>
        : TAccountVault,
      TAccountVaultTokenAccount extends string
        ? WritableAccount<TAccountVaultTokenAccount>
        : TAccountVaultTokenAccount,
      TAccountEscrowAccount extends string
        ? WritableAccount<TAccountEscrowAccount>
        : TAccountEscrowAccount,
      TAccountEscrowAuthority extends string
        ? ReadonlyAccount<TAccountEscrowAuthority>
        : TAccountEscrowAuthority,
      TAccountSap2Program extends string
        ? ReadonlyAccount<TAccountSap2Program>
        : TAccountSap2Program,
      TAccountSap2LoanAccount extends string
        ? ReadonlyAccount<TAccountSap2LoanAccount>
        : TAccountSap2LoanAccount,
      TAccountSap2OfferAccount extends string
        ? ReadonlyAccount<TAccountSap2OfferAccount>
        : TAccountSap2OfferAccount,
      TAccountMaker extends string
        ? WritableSignerAccount<TAccountMaker> &
            AccountSignerMeta<TAccountMaker>
        : TAccountMaker,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      ...TRemainingAccounts,
    ]
  >;

export type OmlpTakeOfferWithFailoverInstructionData = {
  discriminator: ReadonlyUint8Array;
  nonce: bigint;
  borrowAmount: bigint;
  collateralAmount: bigint;
};

export type OmlpTakeOfferWithFailoverInstructionDataArgs = {
  nonce: number | bigint;
  borrowAmount: number | bigint;
  collateralAmount: number | bigint;
};

export function getOmlpTakeOfferWithFailoverInstructionDataEncoder(): FixedSizeEncoder<OmlpTakeOfferWithFailoverInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
      ["nonce", getU64Encoder()],
      ["borrowAmount", getU64Encoder()],
      ["collateralAmount", getU64Encoder()],
    ]),
    (value) => ({
      ...value,
      discriminator: OMLP_TAKE_OFFER_WITH_FAILOVER_DISCRIMINATOR,
    }),
  );
}

export function getOmlpTakeOfferWithFailoverInstructionDataDecoder(): FixedSizeDecoder<OmlpTakeOfferWithFailoverInstructionData> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["nonce", getU64Decoder()],
    ["borrowAmount", getU64Decoder()],
    ["collateralAmount", getU64Decoder()],
  ]);
}

export function getOmlpTakeOfferWithFailoverInstructionDataCodec(): FixedSizeCodec<
  OmlpTakeOfferWithFailoverInstructionDataArgs,
  OmlpTakeOfferWithFailoverInstructionData
> {
  return combineCodec(
    getOmlpTakeOfferWithFailoverInstructionDataEncoder(),
    getOmlpTakeOfferWithFailoverInstructionDataDecoder(),
  );
}

export type OmlpTakeOfferWithFailoverAsyncInput<
  TAccountDualContract extends string = string,
  TAccountRouter extends string = string,
  TAccountVault extends string = string,
  TAccountVaultTokenAccount extends string = string,
  TAccountEscrowAccount extends string = string,
  TAccountEscrowAuthority extends string = string,
  TAccountSap2Program extends string = string,
  TAccountSap2LoanAccount extends string = string,
  TAccountSap2OfferAccount extends string = string,
  TAccountMaker extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountSystemProgram extends string = string,
> = {
  dualContract?: Address<TAccountDualContract>;
  router?: Address<TAccountRouter>;
  vault: Address<TAccountVault>;
  /** Vault's token account (SAP1 source - pooled) */
  vaultTokenAccount: Address<TAccountVaultTokenAccount>;
  /**
   * Escrow account that receives borrowed funds (NOT maker's wallet)
   * Funds go directly to escrow to ensure they're used for collateral
   * and can be repaid when the position is closed
   */
  escrowAccount: Address<TAccountEscrowAccount>;
  escrowAuthority: Address<TAccountEscrowAuthority>;
  /** SAP2 program - optional, used if SAP1 full */
  sap2Program?: Address<TAccountSap2Program>;
  sap2LoanAccount?: Address<TAccountSap2LoanAccount>;
  sap2OfferAccount?: Address<TAccountSap2OfferAccount>;
  maker: TransactionSigner<TAccountMaker>;
  tokenProgram?: Address<TAccountTokenProgram>;
  systemProgram?: Address<TAccountSystemProgram>;
  nonce: OmlpTakeOfferWithFailoverInstructionDataArgs["nonce"];
  borrowAmount: OmlpTakeOfferWithFailoverInstructionDataArgs["borrowAmount"];
  collateralAmount: OmlpTakeOfferWithFailoverInstructionDataArgs["collateralAmount"];
};

export async function getOmlpTakeOfferWithFailoverInstructionAsync<
  TAccountDualContract extends string,
  TAccountRouter extends string,
  TAccountVault extends string,
  TAccountVaultTokenAccount extends string,
  TAccountEscrowAccount extends string,
  TAccountEscrowAuthority extends string,
  TAccountSap2Program extends string,
  TAccountSap2LoanAccount extends string,
  TAccountSap2OfferAccount extends string,
  TAccountMaker extends string,
  TAccountTokenProgram extends string,
  TAccountSystemProgram extends string,
  TProgramAddress extends Address = typeof OPTION_PROGRAM_PROGRAM_ADDRESS,
>(
  input: OmlpTakeOfferWithFailoverAsyncInput<
    TAccountDualContract,
    TAccountRouter,
    TAccountVault,
    TAccountVaultTokenAccount,
    TAccountEscrowAccount,
    TAccountEscrowAuthority,
    TAccountSap2Program,
    TAccountSap2LoanAccount,
    TAccountSap2OfferAccount,
    TAccountMaker,
    TAccountTokenProgram,
    TAccountSystemProgram
  >,
  config?: { programAddress?: TProgramAddress },
): Promise<
  OmlpTakeOfferWithFailoverInstruction<
    TProgramAddress,
    TAccountDualContract,
    TAccountRouter,
    TAccountVault,
    TAccountVaultTokenAccount,
    TAccountEscrowAccount,
    TAccountEscrowAuthority,
    TAccountSap2Program,
    TAccountSap2LoanAccount,
    TAccountSap2OfferAccount,
    TAccountMaker,
    TAccountTokenProgram,
    TAccountSystemProgram
  >
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? OPTION_PROGRAM_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    dualContract: { value: input.dualContract ?? null, isWritable: true },
    router: { value: input.router ?? null, isWritable: true },
    vault: { value: input.vault ?? null, isWritable: true },
    vaultTokenAccount: {
      value: input.vaultTokenAccount ?? null,
      isWritable: true,
    },
    escrowAccount: { value: input.escrowAccount ?? null, isWritable: true },
    escrowAuthority: {
      value: input.escrowAuthority ?? null,
      isWritable: false,
    },
    sap2Program: { value: input.sap2Program ?? null, isWritable: false },
    sap2LoanAccount: {
      value: input.sap2LoanAccount ?? null,
      isWritable: false,
    },
    sap2OfferAccount: {
      value: input.sap2OfferAccount ?? null,
      isWritable: false,
    },
    maker: { value: input.maker ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.router.value) {
    accounts.router.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            108, 105, 113, 117, 105, 100, 105, 116, 121, 95, 114, 111, 117, 116,
            101, 114,
          ]),
        ),
        getAddressEncoder().encode(expectAddress(accounts.vault.value)),
      ],
    });
  }
  if (!accounts.dualContract.value) {
    accounts.dualContract.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            100, 117, 97, 108, 95, 99, 111, 110, 116, 114, 97, 99, 116,
          ]),
        ),
        getAddressEncoder().encode(expectAddress(accounts.maker.value)),
        getAddressEncoder().encode(expectAddress(accounts.router.value)),
        getU64Encoder().encode(expectSome(args.nonce)),
      ],
    });
  }
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address<"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA">;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      "11111111111111111111111111111111" as Address<"11111111111111111111111111111111">;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.dualContract),
      getAccountMeta(accounts.router),
      getAccountMeta(accounts.vault),
      getAccountMeta(accounts.vaultTokenAccount),
      getAccountMeta(accounts.escrowAccount),
      getAccountMeta(accounts.escrowAuthority),
      getAccountMeta(accounts.sap2Program),
      getAccountMeta(accounts.sap2LoanAccount),
      getAccountMeta(accounts.sap2OfferAccount),
      getAccountMeta(accounts.maker),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
    ],
    data: getOmlpTakeOfferWithFailoverInstructionDataEncoder().encode(
      args as OmlpTakeOfferWithFailoverInstructionDataArgs,
    ),
    programAddress,
  } as OmlpTakeOfferWithFailoverInstruction<
    TProgramAddress,
    TAccountDualContract,
    TAccountRouter,
    TAccountVault,
    TAccountVaultTokenAccount,
    TAccountEscrowAccount,
    TAccountEscrowAuthority,
    TAccountSap2Program,
    TAccountSap2LoanAccount,
    TAccountSap2OfferAccount,
    TAccountMaker,
    TAccountTokenProgram,
    TAccountSystemProgram
  >);
}

export type OmlpTakeOfferWithFailoverInput<
  TAccountDualContract extends string = string,
  TAccountRouter extends string = string,
  TAccountVault extends string = string,
  TAccountVaultTokenAccount extends string = string,
  TAccountEscrowAccount extends string = string,
  TAccountEscrowAuthority extends string = string,
  TAccountSap2Program extends string = string,
  TAccountSap2LoanAccount extends string = string,
  TAccountSap2OfferAccount extends string = string,
  TAccountMaker extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountSystemProgram extends string = string,
> = {
  dualContract: Address<TAccountDualContract>;
  router: Address<TAccountRouter>;
  vault: Address<TAccountVault>;
  /** Vault's token account (SAP1 source - pooled) */
  vaultTokenAccount: Address<TAccountVaultTokenAccount>;
  /**
   * Escrow account that receives borrowed funds (NOT maker's wallet)
   * Funds go directly to escrow to ensure they're used for collateral
   * and can be repaid when the position is closed
   */
  escrowAccount: Address<TAccountEscrowAccount>;
  escrowAuthority: Address<TAccountEscrowAuthority>;
  /** SAP2 program - optional, used if SAP1 full */
  sap2Program?: Address<TAccountSap2Program>;
  sap2LoanAccount?: Address<TAccountSap2LoanAccount>;
  sap2OfferAccount?: Address<TAccountSap2OfferAccount>;
  maker: TransactionSigner<TAccountMaker>;
  tokenProgram?: Address<TAccountTokenProgram>;
  systemProgram?: Address<TAccountSystemProgram>;
  nonce: OmlpTakeOfferWithFailoverInstructionDataArgs["nonce"];
  borrowAmount: OmlpTakeOfferWithFailoverInstructionDataArgs["borrowAmount"];
  collateralAmount: OmlpTakeOfferWithFailoverInstructionDataArgs["collateralAmount"];
};

export function getOmlpTakeOfferWithFailoverInstruction<
  TAccountDualContract extends string,
  TAccountRouter extends string,
  TAccountVault extends string,
  TAccountVaultTokenAccount extends string,
  TAccountEscrowAccount extends string,
  TAccountEscrowAuthority extends string,
  TAccountSap2Program extends string,
  TAccountSap2LoanAccount extends string,
  TAccountSap2OfferAccount extends string,
  TAccountMaker extends string,
  TAccountTokenProgram extends string,
  TAccountSystemProgram extends string,
  TProgramAddress extends Address = typeof OPTION_PROGRAM_PROGRAM_ADDRESS,
>(
  input: OmlpTakeOfferWithFailoverInput<
    TAccountDualContract,
    TAccountRouter,
    TAccountVault,
    TAccountVaultTokenAccount,
    TAccountEscrowAccount,
    TAccountEscrowAuthority,
    TAccountSap2Program,
    TAccountSap2LoanAccount,
    TAccountSap2OfferAccount,
    TAccountMaker,
    TAccountTokenProgram,
    TAccountSystemProgram
  >,
  config?: { programAddress?: TProgramAddress },
): OmlpTakeOfferWithFailoverInstruction<
  TProgramAddress,
  TAccountDualContract,
  TAccountRouter,
  TAccountVault,
  TAccountVaultTokenAccount,
  TAccountEscrowAccount,
  TAccountEscrowAuthority,
  TAccountSap2Program,
  TAccountSap2LoanAccount,
  TAccountSap2OfferAccount,
  TAccountMaker,
  TAccountTokenProgram,
  TAccountSystemProgram
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? OPTION_PROGRAM_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    dualContract: { value: input.dualContract ?? null, isWritable: true },
    router: { value: input.router ?? null, isWritable: true },
    vault: { value: input.vault ?? null, isWritable: true },
    vaultTokenAccount: {
      value: input.vaultTokenAccount ?? null,
      isWritable: true,
    },
    escrowAccount: { value: input.escrowAccount ?? null, isWritable: true },
    escrowAuthority: {
      value: input.escrowAuthority ?? null,
      isWritable: false,
    },
    sap2Program: { value: input.sap2Program ?? null, isWritable: false },
    sap2LoanAccount: {
      value: input.sap2LoanAccount ?? null,
      isWritable: false,
    },
    sap2OfferAccount: {
      value: input.sap2OfferAccount ?? null,
      isWritable: false,
    },
    maker: { value: input.maker ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address<"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA">;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      "11111111111111111111111111111111" as Address<"11111111111111111111111111111111">;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.dualContract),
      getAccountMeta(accounts.router),
      getAccountMeta(accounts.vault),
      getAccountMeta(accounts.vaultTokenAccount),
      getAccountMeta(accounts.escrowAccount),
      getAccountMeta(accounts.escrowAuthority),
      getAccountMeta(accounts.sap2Program),
      getAccountMeta(accounts.sap2LoanAccount),
      getAccountMeta(accounts.sap2OfferAccount),
      getAccountMeta(accounts.maker),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
    ],
    data: getOmlpTakeOfferWithFailoverInstructionDataEncoder().encode(
      args as OmlpTakeOfferWithFailoverInstructionDataArgs,
    ),
    programAddress,
  } as OmlpTakeOfferWithFailoverInstruction<
    TProgramAddress,
    TAccountDualContract,
    TAccountRouter,
    TAccountVault,
    TAccountVaultTokenAccount,
    TAccountEscrowAccount,
    TAccountEscrowAuthority,
    TAccountSap2Program,
    TAccountSap2LoanAccount,
    TAccountSap2OfferAccount,
    TAccountMaker,
    TAccountTokenProgram,
    TAccountSystemProgram
  >);
}

export type ParsedOmlpTakeOfferWithFailoverInstruction<
  TProgram extends string = typeof OPTION_PROGRAM_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    dualContract: TAccountMetas[0];
    router: TAccountMetas[1];
    vault: TAccountMetas[2];
    /** Vault's token account (SAP1 source - pooled) */
    vaultTokenAccount: TAccountMetas[3];
    /**
     * Escrow account that receives borrowed funds (NOT maker's wallet)
     * Funds go directly to escrow to ensure they're used for collateral
     * and can be repaid when the position is closed
     */
    escrowAccount: TAccountMetas[4];
    escrowAuthority: TAccountMetas[5];
    /** SAP2 program - optional, used if SAP1 full */
    sap2Program?: TAccountMetas[6] | undefined;
    sap2LoanAccount?: TAccountMetas[7] | undefined;
    sap2OfferAccount?: TAccountMetas[8] | undefined;
    maker: TAccountMetas[9];
    tokenProgram: TAccountMetas[10];
    systemProgram: TAccountMetas[11];
  };
  data: OmlpTakeOfferWithFailoverInstructionData;
};

export function parseOmlpTakeOfferWithFailoverInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>,
): ParsedOmlpTakeOfferWithFailoverInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 12) {
    // TODO: Coded error.
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  const getNextOptionalAccount = () => {
    const accountMeta = getNextAccount();
    return accountMeta.address === OPTION_PROGRAM_PROGRAM_ADDRESS
      ? undefined
      : accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      dualContract: getNextAccount(),
      router: getNextAccount(),
      vault: getNextAccount(),
      vaultTokenAccount: getNextAccount(),
      escrowAccount: getNextAccount(),
      escrowAuthority: getNextAccount(),
      sap2Program: getNextOptionalAccount(),
      sap2LoanAccount: getNextOptionalAccount(),
      sap2OfferAccount: getNextOptionalAccount(),
      maker: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
    },
    data: getOmlpTakeOfferWithFailoverInstructionDataDecoder().decode(
      instruction.data,
    ),
  };
}
