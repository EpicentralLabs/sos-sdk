/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from "@solana/kit";
import { OPTION_PROGRAM_PROGRAM_ADDRESS } from "../programs";
import {
  expectAddress,
  getAccountMetaFactory,
  type ResolvedAccount,
} from "../shared";

export const AUTO_EXERCISE_ALL_EXPIRED_DISCRIMINATOR = new Uint8Array([
  114, 241, 93, 137, 214, 147, 43, 57,
]);

export function getAutoExerciseAllExpiredDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    AUTO_EXERCISE_ALL_EXPIRED_DISCRIMINATOR,
  );
}

export type AutoExerciseAllExpiredInstruction<
  TProgram extends string = typeof OPTION_PROGRAM_PROGRAM_ADDRESS,
  TAccountCollateralPool extends string | AccountMeta<string> = string,
  TAccountOptionPool extends string | AccountMeta<string> = string,
  TAccountOptionAccount extends string | AccountMeta<string> = string,
  TAccountCollateralVault extends string | AccountMeta<string> = string,
  TAccountOmlpVault extends string | AccountMeta<string> = string,
  TAccountOptionMint extends string | AccountMeta<string> = string,
  TAccountPriceUpdate extends string | AccountMeta<string> = string,
  TAccountMarketData extends string | AccountMeta<string> = string,
  TAccountKeeper extends string | AccountMeta<string> = string,
  TAccountTokenProgram extends string | AccountMeta<string> =
    "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
  TAccountSystemProgram extends string | AccountMeta<string> =
    "11111111111111111111111111111111",
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountCollateralPool extends string
        ? WritableAccount<TAccountCollateralPool>
        : TAccountCollateralPool,
      TAccountOptionPool extends string
        ? WritableAccount<TAccountOptionPool>
        : TAccountOptionPool,
      TAccountOptionAccount extends string
        ? WritableAccount<TAccountOptionAccount>
        : TAccountOptionAccount,
      TAccountCollateralVault extends string
        ? WritableAccount<TAccountCollateralVault>
        : TAccountCollateralVault,
      TAccountOmlpVault extends string
        ? WritableAccount<TAccountOmlpVault>
        : TAccountOmlpVault,
      TAccountOptionMint extends string
        ? WritableAccount<TAccountOptionMint>
        : TAccountOptionMint,
      TAccountPriceUpdate extends string
        ? ReadonlyAccount<TAccountPriceUpdate>
        : TAccountPriceUpdate,
      TAccountMarketData extends string
        ? ReadonlyAccount<TAccountMarketData>
        : TAccountMarketData,
      TAccountKeeper extends string
        ? WritableSignerAccount<TAccountKeeper> &
            AccountSignerMeta<TAccountKeeper>
        : TAccountKeeper,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      ...TRemainingAccounts,
    ]
  >;

export type AutoExerciseAllExpiredInstructionData = {
  discriminator: ReadonlyUint8Array;
  maxPositions: number;
};

export type AutoExerciseAllExpiredInstructionDataArgs = {
  maxPositions: number;
};

export function getAutoExerciseAllExpiredInstructionDataEncoder(): FixedSizeEncoder<AutoExerciseAllExpiredInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
      ["maxPositions", getU8Encoder()],
    ]),
    (value) => ({
      ...value,
      discriminator: AUTO_EXERCISE_ALL_EXPIRED_DISCRIMINATOR,
    }),
  );
}

export function getAutoExerciseAllExpiredInstructionDataDecoder(): FixedSizeDecoder<AutoExerciseAllExpiredInstructionData> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["maxPositions", getU8Decoder()],
  ]);
}

export function getAutoExerciseAllExpiredInstructionDataCodec(): FixedSizeCodec<
  AutoExerciseAllExpiredInstructionDataArgs,
  AutoExerciseAllExpiredInstructionData
> {
  return combineCodec(
    getAutoExerciseAllExpiredInstructionDataEncoder(),
    getAutoExerciseAllExpiredInstructionDataDecoder(),
  );
}

export type AutoExerciseAllExpiredAsyncInput<
  TAccountCollateralPool extends string = string,
  TAccountOptionPool extends string = string,
  TAccountOptionAccount extends string = string,
  TAccountCollateralVault extends string = string,
  TAccountOmlpVault extends string = string,
  TAccountOptionMint extends string = string,
  TAccountPriceUpdate extends string = string,
  TAccountMarketData extends string = string,
  TAccountKeeper extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountSystemProgram extends string = string,
> = {
  collateralPool?: Address<TAccountCollateralPool>;
  optionPool: Address<TAccountOptionPool>;
  optionAccount: Address<TAccountOptionAccount>;
  /** Pool's collateral vault (source of payout) */
  collateralVault: Address<TAccountCollateralVault>;
  /** OMLP Vault token account to receive repayments */
  omlpVault: Address<TAccountOmlpVault>;
  /** Option mint (for burning) */
  optionMint: Address<TAccountOptionMint>;
  /** Pyth price update account (ownership validated by Anchor) */
  priceUpdate: Address<TAccountPriceUpdate>;
  /** Market data for this underlying asset (contains pyth_feed_id) */
  marketData: Address<TAccountMarketData>;
  /** Keeper who pays for gas - anyone can call this after expiration */
  keeper: TransactionSigner<TAccountKeeper>;
  tokenProgram?: Address<TAccountTokenProgram>;
  systemProgram?: Address<TAccountSystemProgram>;
  maxPositions: AutoExerciseAllExpiredInstructionDataArgs["maxPositions"];
};

export async function getAutoExerciseAllExpiredInstructionAsync<
  TAccountCollateralPool extends string,
  TAccountOptionPool extends string,
  TAccountOptionAccount extends string,
  TAccountCollateralVault extends string,
  TAccountOmlpVault extends string,
  TAccountOptionMint extends string,
  TAccountPriceUpdate extends string,
  TAccountMarketData extends string,
  TAccountKeeper extends string,
  TAccountTokenProgram extends string,
  TAccountSystemProgram extends string,
  TProgramAddress extends Address = typeof OPTION_PROGRAM_PROGRAM_ADDRESS,
>(
  input: AutoExerciseAllExpiredAsyncInput<
    TAccountCollateralPool,
    TAccountOptionPool,
    TAccountOptionAccount,
    TAccountCollateralVault,
    TAccountOmlpVault,
    TAccountOptionMint,
    TAccountPriceUpdate,
    TAccountMarketData,
    TAccountKeeper,
    TAccountTokenProgram,
    TAccountSystemProgram
  >,
  config?: { programAddress?: TProgramAddress },
): Promise<
  AutoExerciseAllExpiredInstruction<
    TProgramAddress,
    TAccountCollateralPool,
    TAccountOptionPool,
    TAccountOptionAccount,
    TAccountCollateralVault,
    TAccountOmlpVault,
    TAccountOptionMint,
    TAccountPriceUpdate,
    TAccountMarketData,
    TAccountKeeper,
    TAccountTokenProgram,
    TAccountSystemProgram
  >
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? OPTION_PROGRAM_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    collateralPool: { value: input.collateralPool ?? null, isWritable: true },
    optionPool: { value: input.optionPool ?? null, isWritable: true },
    optionAccount: { value: input.optionAccount ?? null, isWritable: true },
    collateralVault: { value: input.collateralVault ?? null, isWritable: true },
    omlpVault: { value: input.omlpVault ?? null, isWritable: true },
    optionMint: { value: input.optionMint ?? null, isWritable: true },
    priceUpdate: { value: input.priceUpdate ?? null, isWritable: false },
    marketData: { value: input.marketData ?? null, isWritable: false },
    keeper: { value: input.keeper ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.collateralPool.value) {
    accounts.collateralPool.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            99, 111, 108, 108, 97, 116, 101, 114, 97, 108, 95, 112, 111, 111,
            108,
          ]),
        ),
        getAddressEncoder().encode(expectAddress(accounts.optionAccount.value)),
      ],
    });
  }
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address<"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA">;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      "11111111111111111111111111111111" as Address<"11111111111111111111111111111111">;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.collateralPool),
      getAccountMeta(accounts.optionPool),
      getAccountMeta(accounts.optionAccount),
      getAccountMeta(accounts.collateralVault),
      getAccountMeta(accounts.omlpVault),
      getAccountMeta(accounts.optionMint),
      getAccountMeta(accounts.priceUpdate),
      getAccountMeta(accounts.marketData),
      getAccountMeta(accounts.keeper),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
    ],
    data: getAutoExerciseAllExpiredInstructionDataEncoder().encode(
      args as AutoExerciseAllExpiredInstructionDataArgs,
    ),
    programAddress,
  } as AutoExerciseAllExpiredInstruction<
    TProgramAddress,
    TAccountCollateralPool,
    TAccountOptionPool,
    TAccountOptionAccount,
    TAccountCollateralVault,
    TAccountOmlpVault,
    TAccountOptionMint,
    TAccountPriceUpdate,
    TAccountMarketData,
    TAccountKeeper,
    TAccountTokenProgram,
    TAccountSystemProgram
  >);
}

export type AutoExerciseAllExpiredInput<
  TAccountCollateralPool extends string = string,
  TAccountOptionPool extends string = string,
  TAccountOptionAccount extends string = string,
  TAccountCollateralVault extends string = string,
  TAccountOmlpVault extends string = string,
  TAccountOptionMint extends string = string,
  TAccountPriceUpdate extends string = string,
  TAccountMarketData extends string = string,
  TAccountKeeper extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountSystemProgram extends string = string,
> = {
  collateralPool: Address<TAccountCollateralPool>;
  optionPool: Address<TAccountOptionPool>;
  optionAccount: Address<TAccountOptionAccount>;
  /** Pool's collateral vault (source of payout) */
  collateralVault: Address<TAccountCollateralVault>;
  /** OMLP Vault token account to receive repayments */
  omlpVault: Address<TAccountOmlpVault>;
  /** Option mint (for burning) */
  optionMint: Address<TAccountOptionMint>;
  /** Pyth price update account (ownership validated by Anchor) */
  priceUpdate: Address<TAccountPriceUpdate>;
  /** Market data for this underlying asset (contains pyth_feed_id) */
  marketData: Address<TAccountMarketData>;
  /** Keeper who pays for gas - anyone can call this after expiration */
  keeper: TransactionSigner<TAccountKeeper>;
  tokenProgram?: Address<TAccountTokenProgram>;
  systemProgram?: Address<TAccountSystemProgram>;
  maxPositions: AutoExerciseAllExpiredInstructionDataArgs["maxPositions"];
};

export function getAutoExerciseAllExpiredInstruction<
  TAccountCollateralPool extends string,
  TAccountOptionPool extends string,
  TAccountOptionAccount extends string,
  TAccountCollateralVault extends string,
  TAccountOmlpVault extends string,
  TAccountOptionMint extends string,
  TAccountPriceUpdate extends string,
  TAccountMarketData extends string,
  TAccountKeeper extends string,
  TAccountTokenProgram extends string,
  TAccountSystemProgram extends string,
  TProgramAddress extends Address = typeof OPTION_PROGRAM_PROGRAM_ADDRESS,
>(
  input: AutoExerciseAllExpiredInput<
    TAccountCollateralPool,
    TAccountOptionPool,
    TAccountOptionAccount,
    TAccountCollateralVault,
    TAccountOmlpVault,
    TAccountOptionMint,
    TAccountPriceUpdate,
    TAccountMarketData,
    TAccountKeeper,
    TAccountTokenProgram,
    TAccountSystemProgram
  >,
  config?: { programAddress?: TProgramAddress },
): AutoExerciseAllExpiredInstruction<
  TProgramAddress,
  TAccountCollateralPool,
  TAccountOptionPool,
  TAccountOptionAccount,
  TAccountCollateralVault,
  TAccountOmlpVault,
  TAccountOptionMint,
  TAccountPriceUpdate,
  TAccountMarketData,
  TAccountKeeper,
  TAccountTokenProgram,
  TAccountSystemProgram
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? OPTION_PROGRAM_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    collateralPool: { value: input.collateralPool ?? null, isWritable: true },
    optionPool: { value: input.optionPool ?? null, isWritable: true },
    optionAccount: { value: input.optionAccount ?? null, isWritable: true },
    collateralVault: { value: input.collateralVault ?? null, isWritable: true },
    omlpVault: { value: input.omlpVault ?? null, isWritable: true },
    optionMint: { value: input.optionMint ?? null, isWritable: true },
    priceUpdate: { value: input.priceUpdate ?? null, isWritable: false },
    marketData: { value: input.marketData ?? null, isWritable: false },
    keeper: { value: input.keeper ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address<"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA">;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      "11111111111111111111111111111111" as Address<"11111111111111111111111111111111">;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.collateralPool),
      getAccountMeta(accounts.optionPool),
      getAccountMeta(accounts.optionAccount),
      getAccountMeta(accounts.collateralVault),
      getAccountMeta(accounts.omlpVault),
      getAccountMeta(accounts.optionMint),
      getAccountMeta(accounts.priceUpdate),
      getAccountMeta(accounts.marketData),
      getAccountMeta(accounts.keeper),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
    ],
    data: getAutoExerciseAllExpiredInstructionDataEncoder().encode(
      args as AutoExerciseAllExpiredInstructionDataArgs,
    ),
    programAddress,
  } as AutoExerciseAllExpiredInstruction<
    TProgramAddress,
    TAccountCollateralPool,
    TAccountOptionPool,
    TAccountOptionAccount,
    TAccountCollateralVault,
    TAccountOmlpVault,
    TAccountOptionMint,
    TAccountPriceUpdate,
    TAccountMarketData,
    TAccountKeeper,
    TAccountTokenProgram,
    TAccountSystemProgram
  >);
}

export type ParsedAutoExerciseAllExpiredInstruction<
  TProgram extends string = typeof OPTION_PROGRAM_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    collateralPool: TAccountMetas[0];
    optionPool: TAccountMetas[1];
    optionAccount: TAccountMetas[2];
    /** Pool's collateral vault (source of payout) */
    collateralVault: TAccountMetas[3];
    /** OMLP Vault token account to receive repayments */
    omlpVault: TAccountMetas[4];
    /** Option mint (for burning) */
    optionMint: TAccountMetas[5];
    /** Pyth price update account (ownership validated by Anchor) */
    priceUpdate: TAccountMetas[6];
    /** Market data for this underlying asset (contains pyth_feed_id) */
    marketData: TAccountMetas[7];
    /** Keeper who pays for gas - anyone can call this after expiration */
    keeper: TAccountMetas[8];
    tokenProgram: TAccountMetas[9];
    systemProgram: TAccountMetas[10];
  };
  data: AutoExerciseAllExpiredInstructionData;
};

export function parseAutoExerciseAllExpiredInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>,
): ParsedAutoExerciseAllExpiredInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 11) {
    // TODO: Coded error.
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      collateralPool: getNextAccount(),
      optionPool: getNextAccount(),
      optionAccount: getNextAccount(),
      collateralVault: getNextAccount(),
      omlpVault: getNextAccount(),
      optionMint: getNextAccount(),
      priceUpdate: getNextAccount(),
      marketData: getNextAccount(),
      keeper: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
    },
    data: getAutoExerciseAllExpiredInstructionDataDecoder().decode(
      instruction.data,
    ),
  };
}
