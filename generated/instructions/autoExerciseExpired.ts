/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getStructEncoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from "@solana/kit";
import { OPTION_PROGRAM_PROGRAM_ADDRESS } from "../programs";
import {
  expectAddress,
  getAccountMetaFactory,
  type ResolvedAccount,
} from "../shared";

export const AUTO_EXERCISE_EXPIRED_DISCRIMINATOR = new Uint8Array([
  93, 222, 81, 8, 181, 25, 68, 25,
]);

export function getAutoExerciseExpiredDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    AUTO_EXERCISE_EXPIRED_DISCRIMINATOR,
  );
}

export type AutoExerciseExpiredInstruction<
  TProgram extends string = typeof OPTION_PROGRAM_PROGRAM_ADDRESS,
  TAccountCollateralPool extends string | AccountMeta<string> = string,
  TAccountOptionPool extends string | AccountMeta<string> = string,
  TAccountOptionAccount extends string | AccountMeta<string> = string,
  TAccountUnderlyingMint extends string | AccountMeta<string> = string,
  TAccountPositionAccount extends string | AccountMeta<string> = string,
  TAccountCollateralVault extends string | AccountMeta<string> = string,
  TAccountBuyerPaymentAccount extends string | AccountMeta<string> = string,
  TAccountBuyerOptionAccount extends string | AccountMeta<string> = string,
  TAccountOptionMint extends string | AccountMeta<string> = string,
  TAccountPriceUpdate extends string | AccountMeta<string> = string,
  TAccountMarketData extends string | AccountMeta<string> = string,
  TAccountOmlpVault extends string | AccountMeta<string> = string,
  TAccountKeeper extends string | AccountMeta<string> = string,
  TAccountTokenProgram extends string | AccountMeta<string> =
    "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
  TAccountSystemProgram extends string | AccountMeta<string> =
    "11111111111111111111111111111111",
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountCollateralPool extends string
        ? WritableAccount<TAccountCollateralPool>
        : TAccountCollateralPool,
      TAccountOptionPool extends string
        ? WritableAccount<TAccountOptionPool>
        : TAccountOptionPool,
      TAccountOptionAccount extends string
        ? WritableAccount<TAccountOptionAccount>
        : TAccountOptionAccount,
      TAccountUnderlyingMint extends string
        ? ReadonlyAccount<TAccountUnderlyingMint>
        : TAccountUnderlyingMint,
      TAccountPositionAccount extends string
        ? WritableAccount<TAccountPositionAccount>
        : TAccountPositionAccount,
      TAccountCollateralVault extends string
        ? WritableAccount<TAccountCollateralVault>
        : TAccountCollateralVault,
      TAccountBuyerPaymentAccount extends string
        ? WritableAccount<TAccountBuyerPaymentAccount>
        : TAccountBuyerPaymentAccount,
      TAccountBuyerOptionAccount extends string
        ? WritableAccount<TAccountBuyerOptionAccount>
        : TAccountBuyerOptionAccount,
      TAccountOptionMint extends string
        ? WritableAccount<TAccountOptionMint>
        : TAccountOptionMint,
      TAccountPriceUpdate extends string
        ? ReadonlyAccount<TAccountPriceUpdate>
        : TAccountPriceUpdate,
      TAccountMarketData extends string
        ? ReadonlyAccount<TAccountMarketData>
        : TAccountMarketData,
      TAccountOmlpVault extends string
        ? WritableAccount<TAccountOmlpVault>
        : TAccountOmlpVault,
      TAccountKeeper extends string
        ? WritableSignerAccount<TAccountKeeper> &
            AccountSignerMeta<TAccountKeeper>
        : TAccountKeeper,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      ...TRemainingAccounts,
    ]
  >;

export type AutoExerciseExpiredInstructionData = {
  discriminator: ReadonlyUint8Array;
};

export type AutoExerciseExpiredInstructionDataArgs = {};

export function getAutoExerciseExpiredInstructionDataEncoder(): FixedSizeEncoder<AutoExerciseExpiredInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([["discriminator", fixEncoderSize(getBytesEncoder(), 8)]]),
    (value) => ({
      ...value,
      discriminator: AUTO_EXERCISE_EXPIRED_DISCRIMINATOR,
    }),
  );
}

export function getAutoExerciseExpiredInstructionDataDecoder(): FixedSizeDecoder<AutoExerciseExpiredInstructionData> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
  ]);
}

export function getAutoExerciseExpiredInstructionDataCodec(): FixedSizeCodec<
  AutoExerciseExpiredInstructionDataArgs,
  AutoExerciseExpiredInstructionData
> {
  return combineCodec(
    getAutoExerciseExpiredInstructionDataEncoder(),
    getAutoExerciseExpiredInstructionDataDecoder(),
  );
}

export type AutoExerciseExpiredAsyncInput<
  TAccountCollateralPool extends string = string,
  TAccountOptionPool extends string = string,
  TAccountOptionAccount extends string = string,
  TAccountUnderlyingMint extends string = string,
  TAccountPositionAccount extends string = string,
  TAccountCollateralVault extends string = string,
  TAccountBuyerPaymentAccount extends string = string,
  TAccountBuyerOptionAccount extends string = string,
  TAccountOptionMint extends string = string,
  TAccountPriceUpdate extends string = string,
  TAccountMarketData extends string = string,
  TAccountOmlpVault extends string = string,
  TAccountKeeper extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountSystemProgram extends string = string,
> = {
  collateralPool?: Address<TAccountCollateralPool>;
  optionPool: Address<TAccountOptionPool>;
  optionAccount: Address<TAccountOptionAccount>;
  /** Underlying token mint (for dynamic decimal handling - supports any SPL token) */
  underlyingMint: Address<TAccountUnderlyingMint>;
  /**
   * Buyer's position (tracks quantity owned)
   * Note: NO signer constraint - keeper exercises on behalf of buyer
   */
  positionAccount: Address<TAccountPositionAccount>;
  /** Pool's collateral vault (source of payout) */
  collateralVault: Address<TAccountCollateralVault>;
  /** Buyer's WSOL account (receives intrinsic value) */
  buyerPaymentAccount: Address<TAccountBuyerPaymentAccount>;
  /** Buyer's option token account (burns tokens) */
  buyerOptionAccount: Address<TAccountBuyerOptionAccount>;
  /** Option mint (for burning) */
  optionMint: Address<TAccountOptionMint>;
  /** Pyth price update account (ownership validated by Anchor) */
  priceUpdate: Address<TAccountPriceUpdate>;
  /** Market data for this underlying asset (contains pyth_feed_id) */
  marketData: Address<TAccountMarketData>;
  /** OMLP Vault token account to receive repayments */
  omlpVault: Address<TAccountOmlpVault>;
  /** Keeper who pays for gas - anyone can call this after expiration */
  keeper: TransactionSigner<TAccountKeeper>;
  tokenProgram?: Address<TAccountTokenProgram>;
  systemProgram?: Address<TAccountSystemProgram>;
};

export async function getAutoExerciseExpiredInstructionAsync<
  TAccountCollateralPool extends string,
  TAccountOptionPool extends string,
  TAccountOptionAccount extends string,
  TAccountUnderlyingMint extends string,
  TAccountPositionAccount extends string,
  TAccountCollateralVault extends string,
  TAccountBuyerPaymentAccount extends string,
  TAccountBuyerOptionAccount extends string,
  TAccountOptionMint extends string,
  TAccountPriceUpdate extends string,
  TAccountMarketData extends string,
  TAccountOmlpVault extends string,
  TAccountKeeper extends string,
  TAccountTokenProgram extends string,
  TAccountSystemProgram extends string,
  TProgramAddress extends Address = typeof OPTION_PROGRAM_PROGRAM_ADDRESS,
>(
  input: AutoExerciseExpiredAsyncInput<
    TAccountCollateralPool,
    TAccountOptionPool,
    TAccountOptionAccount,
    TAccountUnderlyingMint,
    TAccountPositionAccount,
    TAccountCollateralVault,
    TAccountBuyerPaymentAccount,
    TAccountBuyerOptionAccount,
    TAccountOptionMint,
    TAccountPriceUpdate,
    TAccountMarketData,
    TAccountOmlpVault,
    TAccountKeeper,
    TAccountTokenProgram,
    TAccountSystemProgram
  >,
  config?: { programAddress?: TProgramAddress },
): Promise<
  AutoExerciseExpiredInstruction<
    TProgramAddress,
    TAccountCollateralPool,
    TAccountOptionPool,
    TAccountOptionAccount,
    TAccountUnderlyingMint,
    TAccountPositionAccount,
    TAccountCollateralVault,
    TAccountBuyerPaymentAccount,
    TAccountBuyerOptionAccount,
    TAccountOptionMint,
    TAccountPriceUpdate,
    TAccountMarketData,
    TAccountOmlpVault,
    TAccountKeeper,
    TAccountTokenProgram,
    TAccountSystemProgram
  >
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? OPTION_PROGRAM_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    collateralPool: { value: input.collateralPool ?? null, isWritable: true },
    optionPool: { value: input.optionPool ?? null, isWritable: true },
    optionAccount: { value: input.optionAccount ?? null, isWritable: true },
    underlyingMint: { value: input.underlyingMint ?? null, isWritable: false },
    positionAccount: { value: input.positionAccount ?? null, isWritable: true },
    collateralVault: { value: input.collateralVault ?? null, isWritable: true },
    buyerPaymentAccount: {
      value: input.buyerPaymentAccount ?? null,
      isWritable: true,
    },
    buyerOptionAccount: {
      value: input.buyerOptionAccount ?? null,
      isWritable: true,
    },
    optionMint: { value: input.optionMint ?? null, isWritable: true },
    priceUpdate: { value: input.priceUpdate ?? null, isWritable: false },
    marketData: { value: input.marketData ?? null, isWritable: false },
    omlpVault: { value: input.omlpVault ?? null, isWritable: true },
    keeper: { value: input.keeper ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Resolve default values.
  if (!accounts.collateralPool.value) {
    accounts.collateralPool.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            99, 111, 108, 108, 97, 116, 101, 114, 97, 108, 95, 112, 111, 111,
            108,
          ]),
        ),
        getAddressEncoder().encode(expectAddress(accounts.optionAccount.value)),
      ],
    });
  }
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address<"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA">;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      "11111111111111111111111111111111" as Address<"11111111111111111111111111111111">;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.collateralPool),
      getAccountMeta(accounts.optionPool),
      getAccountMeta(accounts.optionAccount),
      getAccountMeta(accounts.underlyingMint),
      getAccountMeta(accounts.positionAccount),
      getAccountMeta(accounts.collateralVault),
      getAccountMeta(accounts.buyerPaymentAccount),
      getAccountMeta(accounts.buyerOptionAccount),
      getAccountMeta(accounts.optionMint),
      getAccountMeta(accounts.priceUpdate),
      getAccountMeta(accounts.marketData),
      getAccountMeta(accounts.omlpVault),
      getAccountMeta(accounts.keeper),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
    ],
    data: getAutoExerciseExpiredInstructionDataEncoder().encode({}),
    programAddress,
  } as AutoExerciseExpiredInstruction<
    TProgramAddress,
    TAccountCollateralPool,
    TAccountOptionPool,
    TAccountOptionAccount,
    TAccountUnderlyingMint,
    TAccountPositionAccount,
    TAccountCollateralVault,
    TAccountBuyerPaymentAccount,
    TAccountBuyerOptionAccount,
    TAccountOptionMint,
    TAccountPriceUpdate,
    TAccountMarketData,
    TAccountOmlpVault,
    TAccountKeeper,
    TAccountTokenProgram,
    TAccountSystemProgram
  >);
}

export type AutoExerciseExpiredInput<
  TAccountCollateralPool extends string = string,
  TAccountOptionPool extends string = string,
  TAccountOptionAccount extends string = string,
  TAccountUnderlyingMint extends string = string,
  TAccountPositionAccount extends string = string,
  TAccountCollateralVault extends string = string,
  TAccountBuyerPaymentAccount extends string = string,
  TAccountBuyerOptionAccount extends string = string,
  TAccountOptionMint extends string = string,
  TAccountPriceUpdate extends string = string,
  TAccountMarketData extends string = string,
  TAccountOmlpVault extends string = string,
  TAccountKeeper extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountSystemProgram extends string = string,
> = {
  collateralPool: Address<TAccountCollateralPool>;
  optionPool: Address<TAccountOptionPool>;
  optionAccount: Address<TAccountOptionAccount>;
  /** Underlying token mint (for dynamic decimal handling - supports any SPL token) */
  underlyingMint: Address<TAccountUnderlyingMint>;
  /**
   * Buyer's position (tracks quantity owned)
   * Note: NO signer constraint - keeper exercises on behalf of buyer
   */
  positionAccount: Address<TAccountPositionAccount>;
  /** Pool's collateral vault (source of payout) */
  collateralVault: Address<TAccountCollateralVault>;
  /** Buyer's WSOL account (receives intrinsic value) */
  buyerPaymentAccount: Address<TAccountBuyerPaymentAccount>;
  /** Buyer's option token account (burns tokens) */
  buyerOptionAccount: Address<TAccountBuyerOptionAccount>;
  /** Option mint (for burning) */
  optionMint: Address<TAccountOptionMint>;
  /** Pyth price update account (ownership validated by Anchor) */
  priceUpdate: Address<TAccountPriceUpdate>;
  /** Market data for this underlying asset (contains pyth_feed_id) */
  marketData: Address<TAccountMarketData>;
  /** OMLP Vault token account to receive repayments */
  omlpVault: Address<TAccountOmlpVault>;
  /** Keeper who pays for gas - anyone can call this after expiration */
  keeper: TransactionSigner<TAccountKeeper>;
  tokenProgram?: Address<TAccountTokenProgram>;
  systemProgram?: Address<TAccountSystemProgram>;
};

export function getAutoExerciseExpiredInstruction<
  TAccountCollateralPool extends string,
  TAccountOptionPool extends string,
  TAccountOptionAccount extends string,
  TAccountUnderlyingMint extends string,
  TAccountPositionAccount extends string,
  TAccountCollateralVault extends string,
  TAccountBuyerPaymentAccount extends string,
  TAccountBuyerOptionAccount extends string,
  TAccountOptionMint extends string,
  TAccountPriceUpdate extends string,
  TAccountMarketData extends string,
  TAccountOmlpVault extends string,
  TAccountKeeper extends string,
  TAccountTokenProgram extends string,
  TAccountSystemProgram extends string,
  TProgramAddress extends Address = typeof OPTION_PROGRAM_PROGRAM_ADDRESS,
>(
  input: AutoExerciseExpiredInput<
    TAccountCollateralPool,
    TAccountOptionPool,
    TAccountOptionAccount,
    TAccountUnderlyingMint,
    TAccountPositionAccount,
    TAccountCollateralVault,
    TAccountBuyerPaymentAccount,
    TAccountBuyerOptionAccount,
    TAccountOptionMint,
    TAccountPriceUpdate,
    TAccountMarketData,
    TAccountOmlpVault,
    TAccountKeeper,
    TAccountTokenProgram,
    TAccountSystemProgram
  >,
  config?: { programAddress?: TProgramAddress },
): AutoExerciseExpiredInstruction<
  TProgramAddress,
  TAccountCollateralPool,
  TAccountOptionPool,
  TAccountOptionAccount,
  TAccountUnderlyingMint,
  TAccountPositionAccount,
  TAccountCollateralVault,
  TAccountBuyerPaymentAccount,
  TAccountBuyerOptionAccount,
  TAccountOptionMint,
  TAccountPriceUpdate,
  TAccountMarketData,
  TAccountOmlpVault,
  TAccountKeeper,
  TAccountTokenProgram,
  TAccountSystemProgram
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? OPTION_PROGRAM_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    collateralPool: { value: input.collateralPool ?? null, isWritable: true },
    optionPool: { value: input.optionPool ?? null, isWritable: true },
    optionAccount: { value: input.optionAccount ?? null, isWritable: true },
    underlyingMint: { value: input.underlyingMint ?? null, isWritable: false },
    positionAccount: { value: input.positionAccount ?? null, isWritable: true },
    collateralVault: { value: input.collateralVault ?? null, isWritable: true },
    buyerPaymentAccount: {
      value: input.buyerPaymentAccount ?? null,
      isWritable: true,
    },
    buyerOptionAccount: {
      value: input.buyerOptionAccount ?? null,
      isWritable: true,
    },
    optionMint: { value: input.optionMint ?? null, isWritable: true },
    priceUpdate: { value: input.priceUpdate ?? null, isWritable: false },
    marketData: { value: input.marketData ?? null, isWritable: false },
    omlpVault: { value: input.omlpVault ?? null, isWritable: true },
    keeper: { value: input.keeper ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Resolve default values.
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address<"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA">;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      "11111111111111111111111111111111" as Address<"11111111111111111111111111111111">;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.collateralPool),
      getAccountMeta(accounts.optionPool),
      getAccountMeta(accounts.optionAccount),
      getAccountMeta(accounts.underlyingMint),
      getAccountMeta(accounts.positionAccount),
      getAccountMeta(accounts.collateralVault),
      getAccountMeta(accounts.buyerPaymentAccount),
      getAccountMeta(accounts.buyerOptionAccount),
      getAccountMeta(accounts.optionMint),
      getAccountMeta(accounts.priceUpdate),
      getAccountMeta(accounts.marketData),
      getAccountMeta(accounts.omlpVault),
      getAccountMeta(accounts.keeper),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
    ],
    data: getAutoExerciseExpiredInstructionDataEncoder().encode({}),
    programAddress,
  } as AutoExerciseExpiredInstruction<
    TProgramAddress,
    TAccountCollateralPool,
    TAccountOptionPool,
    TAccountOptionAccount,
    TAccountUnderlyingMint,
    TAccountPositionAccount,
    TAccountCollateralVault,
    TAccountBuyerPaymentAccount,
    TAccountBuyerOptionAccount,
    TAccountOptionMint,
    TAccountPriceUpdate,
    TAccountMarketData,
    TAccountOmlpVault,
    TAccountKeeper,
    TAccountTokenProgram,
    TAccountSystemProgram
  >);
}

export type ParsedAutoExerciseExpiredInstruction<
  TProgram extends string = typeof OPTION_PROGRAM_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    collateralPool: TAccountMetas[0];
    optionPool: TAccountMetas[1];
    optionAccount: TAccountMetas[2];
    /** Underlying token mint (for dynamic decimal handling - supports any SPL token) */
    underlyingMint: TAccountMetas[3];
    /**
     * Buyer's position (tracks quantity owned)
     * Note: NO signer constraint - keeper exercises on behalf of buyer
     */
    positionAccount: TAccountMetas[4];
    /** Pool's collateral vault (source of payout) */
    collateralVault: TAccountMetas[5];
    /** Buyer's WSOL account (receives intrinsic value) */
    buyerPaymentAccount: TAccountMetas[6];
    /** Buyer's option token account (burns tokens) */
    buyerOptionAccount: TAccountMetas[7];
    /** Option mint (for burning) */
    optionMint: TAccountMetas[8];
    /** Pyth price update account (ownership validated by Anchor) */
    priceUpdate: TAccountMetas[9];
    /** Market data for this underlying asset (contains pyth_feed_id) */
    marketData: TAccountMetas[10];
    /** OMLP Vault token account to receive repayments */
    omlpVault: TAccountMetas[11];
    /** Keeper who pays for gas - anyone can call this after expiration */
    keeper: TAccountMetas[12];
    tokenProgram: TAccountMetas[13];
    systemProgram: TAccountMetas[14];
  };
  data: AutoExerciseExpiredInstructionData;
};

export function parseAutoExerciseExpiredInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>,
): ParsedAutoExerciseExpiredInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 15) {
    // TODO: Coded error.
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      collateralPool: getNextAccount(),
      optionPool: getNextAccount(),
      optionAccount: getNextAccount(),
      underlyingMint: getNextAccount(),
      positionAccount: getNextAccount(),
      collateralVault: getNextAccount(),
      buyerPaymentAccount: getNextAccount(),
      buyerOptionAccount: getNextAccount(),
      optionMint: getNextAccount(),
      priceUpdate: getNextAccount(),
      marketData: getNextAccount(),
      omlpVault: getNextAccount(),
      keeper: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
    },
    data: getAutoExerciseExpiredInstructionDataDecoder().decode(
      instruction.data,
    ),
  };
}
