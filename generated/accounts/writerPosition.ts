/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getBooleanDecoder,
  getBooleanEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getI64Decoder,
  getI64Encoder,
  getStructDecoder,
  getStructEncoder,
  getU128Decoder,
  getU128Encoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
  type Account,
  type Address,
  type EncodedAccount,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type ReadonlyUint8Array,
} from "@solana/kit";

export const WRITER_POSITION_DISCRIMINATOR = new Uint8Array([
  195, 252, 56, 77, 221, 13, 8, 69,
]);

export function getWriterPositionDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    WRITER_POSITION_DISCRIMINATOR,
  );
}

export type WriterPosition = {
  discriminator: ReadonlyUint8Array;
  /** The writer's wallet address */
  writerAuthority: Address;
  /** Reference to the option pool */
  optionPool: Address;
  /** Reference to the option account */
  optionAccount: Address;
  /**
   * Mint used for collateral backing this position (e.g., USDC, BTC, SOL)
   * Can differ from the underlying asset - enables multi-collateral system
   */
  collateralMint: Address;
  /**
   * Mint used for settlement (same as collateral_mint)
   * Buyers receive payout in this currency
   */
  settlementMint: Address;
  /** Total contracts written (minted) by this writer */
  writtenQty: bigint;
  /** Total contracts sold to buyers (open interest from this writer) */
  soldQty: bigint;
  /** Contracts still available for sale (written_qty - sold_qty - withdrawn_qty) */
  unsoldQty: bigint;
  /** Total contracts withdrawn (unwound before selling) */
  withdrawnQty: bigint;
  /** Writer's own collateral deposited */
  collateralDeposited: bigint;
  /** Total borrowed from OMLP vault */
  borrowedPrincipal: bigint;
  /** Number of active PoolLoan accounts for this writer */
  activeLoanCount: number;
  /** Theta (time-decay) allocated to this writer (from pool accumulator) */
  thetaEarned: bigint;
  /** Theta already claimed/withdrawn */
  thetaClaimed: bigint;
  /** Snapshot of pool's acc_theta_per_oi_fp at last claim (reward-debt pattern) */
  lastPoolAccThetaFp: bigint;
  /** Snapshot of pool's acc_closed_per_oi_fp at last sync */
  lastPoolAccClosedFp: bigint;
  /** Snapshot of pool's acc_payout_per_oi_fp at last sync */
  lastPoolAccPayoutFp: bigint;
  /** Accumulated closed qty debt (for lazy settlement calc) */
  closedQtyDebtFp: bigint;
  /** Accumulated payout debt (for lazy settlement calc) */
  payoutDebtFp: bigint;
  /** Total payout to buyers from this writer's collateral */
  totalBuyerPayout: bigint;
  /** Total repaid to OMLP lenders (principal + interest + fees) */
  totalLenderRepaid: bigint;
  /** Total collateral returned to writer */
  totalCollateralReturned: bigint;
  /** Realized PnL (positive = profit, negative = loss) */
  realizedPnl: bigint;
  /** True if position is fully settled (all loans repaid, collateral returned) */
  isSettled: boolean;
  /** True if position was liquidated */
  isLiquidated: boolean;
  createdAt: bigint;
  lastUpdated: bigint;
  bump: number;
};

export type WriterPositionArgs = {
  /** The writer's wallet address */
  writerAuthority: Address;
  /** Reference to the option pool */
  optionPool: Address;
  /** Reference to the option account */
  optionAccount: Address;
  /**
   * Mint used for collateral backing this position (e.g., USDC, BTC, SOL)
   * Can differ from the underlying asset - enables multi-collateral system
   */
  collateralMint: Address;
  /**
   * Mint used for settlement (same as collateral_mint)
   * Buyers receive payout in this currency
   */
  settlementMint: Address;
  /** Total contracts written (minted) by this writer */
  writtenQty: number | bigint;
  /** Total contracts sold to buyers (open interest from this writer) */
  soldQty: number | bigint;
  /** Contracts still available for sale (written_qty - sold_qty - withdrawn_qty) */
  unsoldQty: number | bigint;
  /** Total contracts withdrawn (unwound before selling) */
  withdrawnQty: number | bigint;
  /** Writer's own collateral deposited */
  collateralDeposited: number | bigint;
  /** Total borrowed from OMLP vault */
  borrowedPrincipal: number | bigint;
  /** Number of active PoolLoan accounts for this writer */
  activeLoanCount: number;
  /** Theta (time-decay) allocated to this writer (from pool accumulator) */
  thetaEarned: number | bigint;
  /** Theta already claimed/withdrawn */
  thetaClaimed: number | bigint;
  /** Snapshot of pool's acc_theta_per_oi_fp at last claim (reward-debt pattern) */
  lastPoolAccThetaFp: number | bigint;
  /** Snapshot of pool's acc_closed_per_oi_fp at last sync */
  lastPoolAccClosedFp: number | bigint;
  /** Snapshot of pool's acc_payout_per_oi_fp at last sync */
  lastPoolAccPayoutFp: number | bigint;
  /** Accumulated closed qty debt (for lazy settlement calc) */
  closedQtyDebtFp: number | bigint;
  /** Accumulated payout debt (for lazy settlement calc) */
  payoutDebtFp: number | bigint;
  /** Total payout to buyers from this writer's collateral */
  totalBuyerPayout: number | bigint;
  /** Total repaid to OMLP lenders (principal + interest + fees) */
  totalLenderRepaid: number | bigint;
  /** Total collateral returned to writer */
  totalCollateralReturned: number | bigint;
  /** Realized PnL (positive = profit, negative = loss) */
  realizedPnl: number | bigint;
  /** True if position is fully settled (all loans repaid, collateral returned) */
  isSettled: boolean;
  /** True if position was liquidated */
  isLiquidated: boolean;
  createdAt: number | bigint;
  lastUpdated: number | bigint;
  bump: number;
};

/** Gets the encoder for {@link WriterPositionArgs} account data. */
export function getWriterPositionEncoder(): FixedSizeEncoder<WriterPositionArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
      ["writerAuthority", getAddressEncoder()],
      ["optionPool", getAddressEncoder()],
      ["optionAccount", getAddressEncoder()],
      ["collateralMint", getAddressEncoder()],
      ["settlementMint", getAddressEncoder()],
      ["writtenQty", getU64Encoder()],
      ["soldQty", getU64Encoder()],
      ["unsoldQty", getU64Encoder()],
      ["withdrawnQty", getU64Encoder()],
      ["collateralDeposited", getU64Encoder()],
      ["borrowedPrincipal", getU64Encoder()],
      ["activeLoanCount", getU8Encoder()],
      ["thetaEarned", getU64Encoder()],
      ["thetaClaimed", getU64Encoder()],
      ["lastPoolAccThetaFp", getU128Encoder()],
      ["lastPoolAccClosedFp", getU128Encoder()],
      ["lastPoolAccPayoutFp", getU128Encoder()],
      ["closedQtyDebtFp", getU128Encoder()],
      ["payoutDebtFp", getU128Encoder()],
      ["totalBuyerPayout", getU64Encoder()],
      ["totalLenderRepaid", getU64Encoder()],
      ["totalCollateralReturned", getU64Encoder()],
      ["realizedPnl", getI64Encoder()],
      ["isSettled", getBooleanEncoder()],
      ["isLiquidated", getBooleanEncoder()],
      ["createdAt", getI64Encoder()],
      ["lastUpdated", getI64Encoder()],
      ["bump", getU8Encoder()],
    ]),
    (value) => ({ ...value, discriminator: WRITER_POSITION_DISCRIMINATOR }),
  );
}

/** Gets the decoder for {@link WriterPosition} account data. */
export function getWriterPositionDecoder(): FixedSizeDecoder<WriterPosition> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["writerAuthority", getAddressDecoder()],
    ["optionPool", getAddressDecoder()],
    ["optionAccount", getAddressDecoder()],
    ["collateralMint", getAddressDecoder()],
    ["settlementMint", getAddressDecoder()],
    ["writtenQty", getU64Decoder()],
    ["soldQty", getU64Decoder()],
    ["unsoldQty", getU64Decoder()],
    ["withdrawnQty", getU64Decoder()],
    ["collateralDeposited", getU64Decoder()],
    ["borrowedPrincipal", getU64Decoder()],
    ["activeLoanCount", getU8Decoder()],
    ["thetaEarned", getU64Decoder()],
    ["thetaClaimed", getU64Decoder()],
    ["lastPoolAccThetaFp", getU128Decoder()],
    ["lastPoolAccClosedFp", getU128Decoder()],
    ["lastPoolAccPayoutFp", getU128Decoder()],
    ["closedQtyDebtFp", getU128Decoder()],
    ["payoutDebtFp", getU128Decoder()],
    ["totalBuyerPayout", getU64Decoder()],
    ["totalLenderRepaid", getU64Decoder()],
    ["totalCollateralReturned", getU64Decoder()],
    ["realizedPnl", getI64Decoder()],
    ["isSettled", getBooleanDecoder()],
    ["isLiquidated", getBooleanDecoder()],
    ["createdAt", getI64Decoder()],
    ["lastUpdated", getI64Decoder()],
    ["bump", getU8Decoder()],
  ]);
}

/** Gets the codec for {@link WriterPosition} account data. */
export function getWriterPositionCodec(): FixedSizeCodec<
  WriterPositionArgs,
  WriterPosition
> {
  return combineCodec(getWriterPositionEncoder(), getWriterPositionDecoder());
}

export function decodeWriterPosition<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>,
): Account<WriterPosition, TAddress>;
export function decodeWriterPosition<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>,
): MaybeAccount<WriterPosition, TAddress>;
export function decodeWriterPosition<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,
): Account<WriterPosition, TAddress> | MaybeAccount<WriterPosition, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getWriterPositionDecoder(),
  );
}

export async function fetchWriterPosition<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<Account<WriterPosition, TAddress>> {
  const maybeAccount = await fetchMaybeWriterPosition(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeWriterPosition<
  TAddress extends string = string,
>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<MaybeAccount<WriterPosition, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeWriterPosition(maybeAccount);
}

export async function fetchAllWriterPosition(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<Account<WriterPosition>[]> {
  const maybeAccounts = await fetchAllMaybeWriterPosition(
    rpc,
    addresses,
    config,
  );
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeWriterPosition(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<MaybeAccount<WriterPosition>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) =>
    decodeWriterPosition(maybeAccount),
  );
}

export function getWriterPositionSize(): number {
  return 364;
}
