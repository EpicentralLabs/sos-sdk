/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getOptionDecoder,
  getOptionEncoder,
  getStructDecoder,
  getStructEncoder,
  getU16Decoder,
  getU16Encoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
  type Account,
  type Address,
  type Codec,
  type Decoder,
  type EncodedAccount,
  type Encoder,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type Option,
  type OptionOrNullable,
  type ReadonlyUint8Array,
} from "@solana/kit";
import {
  getSap2ProviderDecoder,
  getSap2ProviderEncoder,
  type Sap2Provider,
  type Sap2ProviderArgs,
} from "../types";

export const DUAL_SOURCE_CONTRACT_DISCRIMINATOR = new Uint8Array([
  114, 105, 97, 181, 162, 170, 126, 215,
]);

export function getDualSourceContractDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    DUAL_SOURCE_CONTRACT_DISCRIMINATOR,
  );
}

export type DualSourceContract = {
  discriminator: ReadonlyUint8Array;
  /** Standard contract fields */
  maker: Address;
  /**
   * Escrow account where borrowed funds were deposited
   * This ensures funds can only be used for collateral, not misappropriated
   */
  escrowAccount: Address;
  principal: bigint;
  accrued: bigint;
  healthBps: number;
  startSlot: bigint;
  lastUpdateSlot: bigint;
  status: number;
  collateralFrozen: bigint;
  nonce: bigint;
  /** Liquidity source tracking */
  sap1Amount: bigint;
  sap2Amount: bigint;
  sap1Offer: Option<Address>;
  sap2LoanId: Option<bigint>;
  sap2Provider: Option<Sap2Provider>;
};

export type DualSourceContractArgs = {
  /** Standard contract fields */
  maker: Address;
  /**
   * Escrow account where borrowed funds were deposited
   * This ensures funds can only be used for collateral, not misappropriated
   */
  escrowAccount: Address;
  principal: number | bigint;
  accrued: number | bigint;
  healthBps: number;
  startSlot: number | bigint;
  lastUpdateSlot: number | bigint;
  status: number;
  collateralFrozen: number | bigint;
  nonce: number | bigint;
  /** Liquidity source tracking */
  sap1Amount: number | bigint;
  sap2Amount: number | bigint;
  sap1Offer: OptionOrNullable<Address>;
  sap2LoanId: OptionOrNullable<number | bigint>;
  sap2Provider: OptionOrNullable<Sap2ProviderArgs>;
};

/** Gets the encoder for {@link DualSourceContractArgs} account data. */
export function getDualSourceContractEncoder(): Encoder<DualSourceContractArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
      ["maker", getAddressEncoder()],
      ["escrowAccount", getAddressEncoder()],
      ["principal", getU64Encoder()],
      ["accrued", getU64Encoder()],
      ["healthBps", getU16Encoder()],
      ["startSlot", getU64Encoder()],
      ["lastUpdateSlot", getU64Encoder()],
      ["status", getU8Encoder()],
      ["collateralFrozen", getU64Encoder()],
      ["nonce", getU64Encoder()],
      ["sap1Amount", getU64Encoder()],
      ["sap2Amount", getU64Encoder()],
      ["sap1Offer", getOptionEncoder(getAddressEncoder())],
      ["sap2LoanId", getOptionEncoder(getU64Encoder())],
      ["sap2Provider", getOptionEncoder(getSap2ProviderEncoder())],
    ]),
    (value) => ({
      ...value,
      discriminator: DUAL_SOURCE_CONTRACT_DISCRIMINATOR,
    }),
  );
}

/** Gets the decoder for {@link DualSourceContract} account data. */
export function getDualSourceContractDecoder(): Decoder<DualSourceContract> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["maker", getAddressDecoder()],
    ["escrowAccount", getAddressDecoder()],
    ["principal", getU64Decoder()],
    ["accrued", getU64Decoder()],
    ["healthBps", getU16Decoder()],
    ["startSlot", getU64Decoder()],
    ["lastUpdateSlot", getU64Decoder()],
    ["status", getU8Decoder()],
    ["collateralFrozen", getU64Decoder()],
    ["nonce", getU64Decoder()],
    ["sap1Amount", getU64Decoder()],
    ["sap2Amount", getU64Decoder()],
    ["sap1Offer", getOptionDecoder(getAddressDecoder())],
    ["sap2LoanId", getOptionDecoder(getU64Decoder())],
    ["sap2Provider", getOptionDecoder(getSap2ProviderDecoder())],
  ]);
}

/** Gets the codec for {@link DualSourceContract} account data. */
export function getDualSourceContractCodec(): Codec<
  DualSourceContractArgs,
  DualSourceContract
> {
  return combineCodec(
    getDualSourceContractEncoder(),
    getDualSourceContractDecoder(),
  );
}

export function decodeDualSourceContract<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>,
): Account<DualSourceContract, TAddress>;
export function decodeDualSourceContract<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>,
): MaybeAccount<DualSourceContract, TAddress>;
export function decodeDualSourceContract<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,
):
  | Account<DualSourceContract, TAddress>
  | MaybeAccount<DualSourceContract, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getDualSourceContractDecoder(),
  );
}

export async function fetchDualSourceContract<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<Account<DualSourceContract, TAddress>> {
  const maybeAccount = await fetchMaybeDualSourceContract(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeDualSourceContract<
  TAddress extends string = string,
>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<MaybeAccount<DualSourceContract, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeDualSourceContract(maybeAccount);
}

export async function fetchAllDualSourceContract(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<Account<DualSourceContract>[]> {
  const maybeAccounts = await fetchAllMaybeDualSourceContract(
    rpc,
    addresses,
    config,
  );
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeDualSourceContract(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<MaybeAccount<DualSourceContract>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) =>
    decodeDualSourceContract(maybeAccount),
  );
}
